package provide wylib 0.20	;#Oct 2001
# Maintain application preferences in an rc file.
#------------------------------------------
#Copyright (C) 1999-2001 Wyatt-ERP LLC.  All other rights reserved.
#This program is free software. You can redistribute it and/or modify it under the terms of the Open Public License as published by PIC Development Group and the Open Solutions Group.
#The program is distributed with the hope that it will be useful and beneficial, but WITHOUT ANY WARRANTY, without even the implied warranty of MERCAHANTABILLITY or FITNESS FOR A PARTICULAR PURPOSE. See the license agreement for further details.
#You should have received a copy of the Open Public License along with this program. If you did not, please visit www.opl.org to obtain a copy.
#------------------------------------------
#TODO:
#- Way to set behavior of individual modules in preferences
#- Way for modules to access their pref values
#- New colors don't show up in global prefs after a restart
#- 
#- 

option add *Entry.font {Courier 12} widgetDefault
option add *Text.font {Courier 12} widgetDefault
option add *Listbox.font {Courier 12} widgetDefault
option add *Label.font {Helvetica 12 bold} widgetDefault
option add *Button.font {Helvetica 12 bold} widgetDefault
option add *Menubutton.font {Helvetica 12 bold} widgetDefault
option add *Menu.font {Helvetica 12 bold} widgetDefault

option add *Entry.background {#f0f0f0} widgetDefault
option add *Text.background {#eeeeee} widgetDefault
option add *Listbox.background {#eeeeee} widgetDefault

namespace eval pref {
    namespace export init
    variable cfig
    variable vals
    variable opts
    variable font

#	{g_bgnd		clr	{Background:}		{background pal frame} -help {Default background for all items}}
#	{g_fgnd		clr	{Foreground:}		{foreground pal label} -help {Default text color for all items}}
#	{g_ebgnd	clr	{Entry Background:}	{background *Entry.background entry} -help {Default background color for entries}}
#	{g_tbgnd	clr	{Textbox Background:}	{background *Text.background text} -help {Default background color for textboxes}}
#	{g_lbbgnd	clr	{Listbox Background:}	{background *Listbox.background listbox} -help {Default background color for listboxes}}

    #global preference definitions
    set cfig(defs.global) {
	{g_efont	fnt	{Entry Font:}		{font *Entry.font entry} -help {Default font for entry fields}}
	{g_lbfont	fnt	{Listbox Font:}		{font *Listbox.font listbox} -help {Default font for listboxes}}
	{g_tfont	fnt	{Textbox Font:}		{font *Text.font text} -help {Default font for textboxes}}
	{g_lfont	fnt	{Label Font:}		{font *Label.font label} -help {Default font for labels}}
	{g_bfont	fnt	{Button Font:}		{font *Button.font button} -help {Default font for buttons}}
	{g_mbfont	fnt	{Menubutton Font:}	{font *Menubutton.font menubutton} -help {Default font for menu buttons}}
	{g_mufont	fnt	{Menu Font:}		{font *Menu.font menu} -help {Default font for menu items}}
	{g_hbbgnd	clr	{Help Balloon Bgnd:}	{background *Helpbal.l.background frame} -help {Default background color for help balloons}}
	{g_helpbs	chk	{Enable Help Balloons:}	help::cfig(balloons) -help {Pop up these little help messages when available}}
    }
    set cfig(f_as) {{geom {}} {help {}} {def {}} {command {}} {menu {}} {native {}} {{*} {} {append ca(native) \" -$s $v\"}}}
}

        
# Load the preferences file(s) and prepare for future calls to set prefs
#------------------------------------------
proc pref::init {cnm args} {
    variable cfig
    upvar $cnm can
    
    argproc ca(\$s) $args {{priv $::cnf(appname)} {global 1} {rcfile {}} {rcfile.global $lib::cfig(appdir)/pref.global} {apply {}} {title {Edit Application Preferences}} {title.global {Edit Preferences for All ATI Applications}}}
    set p $ca(priv)
    if {$ca(rcfile) == {}} "set ca(rcfile) $lib::cfig(appdir)/pref.$p"
    foreach s {title apply rcfile} {set cfig($s.$p) $ca($s)}
    foreach s {title rcfile} {set cfig($s.global) $ca($s.global)}
    foreach rec [set cfig(defs.$p) $can] {
        argproc ca(\$s) [lassign $rec tag type title vname] $cfig(f_as)
        if {[llength $vname] == 1} {		;#if not an option
            uplevel "set $vname \"\[subst \"$ca(def)\"\]\""	;#set the default value
        }
    }
    load_file $cfig(rcfile.$p) $can
    if {$ca(global)} {load_file $cfig(rcfile.global) $cfig(defs.global)}
}

# Load a configuration file
#------------------------------------------
proc pref::load_file {fname defs} {
    if {![file exists $fname]} return
    set palette {}
    foreach {ftag fval} [read_file $fname] {	;#for each pair in the rcfile
        foreach rec $defs {			;#for each expected tag
            lassign $rec tag type title vname
            if {$tag == $ftag} {
                if {[llength $vname] > 1} {
                    lassign $vname oswitch ospec odeft
                    if {$ospec == {pal}} {	;#standard palette option
                        lappend palette $oswitch $fval
#puts "palette:$palette"
                    } else {
#puts "option add $ospec $fval interactive"
                        option add $ospec $fval interactive
                        set pref::opts($ftag) $fval
                    }
                } else {
#puts "variable set $vname $fval"
                    if {[info exists $vname]} {
                        set $vname $fval
                    } else {
                        after idle "set $vname $fval"
                    }
                }
                break
            }
        }
    }
#puts "palette:$palette"
    if {$palette != {}} {eval tk_setPalette $palette}
}

# Save a Configuration file
#------------------------------------------
proc pref::save_file {fname defs} {
    variable vals
    set ostrg {}
    foreach rec $defs {			;#for each variable
        set oargs [lassign $rec tag title type vname]
        append ostrg "[list $tag $vals($tag)]\n"
    }
    write_file $fname $ostrg
}

# Configure all currently open widgets
#------------------------------------------
proc config_tree {w args} {
    set class [winfo class $w]
#puts "\nW:$w CL:$class"
    foreach l $args {			;#for each option
        lassign $l opt val cspec
        set gopt [option get $w $opt $class]

        if {![catch {$w config -$opt} value]} {
        }
        lassign $value p1 p2 p3 def act
#puts "  CONFIG -$opt:$value def:$def act:$act"
 
#        if {$gopt != {} && $def == $act} {}
        if {$gopt != {}} {
#puts "  $w configure -$opt $gopt"
            $w configure -$opt $gopt
        }
#puts "  L:$l OP:-$opt GO:$gopt"
    }
    foreach child [winfo children $w] {
	eval config_tree $child $args
    }
}

# Assert the selected values into their target variables
#------------------------------------------
proc pref::apply {w priv defs} {
    variable cfig
    variable vals
    variable opts
    set arglst {}
    set palette {}
    foreach rec $defs {				;#for each variable
        lassign $rec tag type title vname
        if {[llength $vname] > 1} {		;#if an option
            if {$vals($tag) == {}} continue	;#and a value is given
            lassign $vname oswitch ospec odeft
#puts "option add $ospec $vals($tag) interactive"
            set opts($tag) $vals($tag)
            if {$ospec == {pal}} {	;#standard palette option
                lappend palette $oswitch $vals($tag)
            } else {
                option add $ospec $vals($tag) interactive		;#apply it
                lappend arglst [list $oswitch $vals($tag) $ospec]	;#and save it
            }
        } else {
            set $vname $vals($tag)	;#else just set the variable
        }
    }

    if {$palette != {}} {eval tk_setPalette $palette}
    if {$arglst != {}} {eval config_tree . $arglst}
    foreach rec $defs {				;#for each variable
        lassign $rec tag type
        if {$type == {clr} && $vals($tag) != {}} {$w.f.l_$tag configure -bg $vals($tag)}
    }
    if {$priv != {global} && $cfig(apply.$priv) != {}} {eval $cfig(apply.$priv)}	;#execute the user script
}

# Allow the user to select a color, drop it in a variable and widget background
#------------------------------------------
proc pref::getcolor {vname args} {
    upvar $vname v
    set clr [tk_chooseColor -initialcolor $v]
    if {$clr == {}} {set clr $v}
    if {$clr == {}} {set clr ivory3}
    if {$args != {}} {$args configure -bg $clr}
    set v $clr
}

# Set all the boxes that have a tag that looks like a geometry of some kind (geom*)
#------------------------------------------
proc pref::geoms {p} {
    variable cfig
    variable vals
    foreach rec $cfig(defs.$p) {
        argproc ca(\$s) [lassign $rec tag type title vname] $cfig(f_as)
        if {$ca(geom) != {}} {
            if {[llength $ca(geom)] == 1} {	;#toplevel geometry
                if {[set cg [eval curgeom $ca(geom)]] !=  {}} {set vals($tag) $cg}
            } elseif {![catch $ca(geom) val]} {
                set vals($tag) $val
            }
        }
    }
}

# Return the current window geometry
# w:	The window's geometry to use
# tag:	Index into vals() for default value
# full: include placement in geometry else include size only
#------------------------------------------
proc pref::curgeom {w {full 0}} {
    variable vals
    if {![winfo exists $w]} {return {}}
    if {$full} {return [wm geometry $w]}
    lassign [split [wm geometry $w] "x+"] sx sy x y
    return "${sx}x${sy}"
}

# Update the title font in the getfont widget
#------------------------------------------
proc pref::updfont {} {
    variable font
#puts "fam:$font(fam) size:$font(size) style:$font(style)"
    if {[catch {.fontsel.t configure -font "$font(fam) $font(size) $font(style)"}]} {
        error "Invalid font: $font(fam) $font(size) $font(style)"
        set font(size) -12
        return 0
    }
    return 1
}

# Select a font
#------------------------------------------
proc pref::getfont {p vname} {
    variable font
    upvar $vname v
    set w .fontsel
    if {[winfo exists $w]} {destroy $w}
    toplevel $w -class Fontsel
    wm transient $w [winfo parent $p]	;#make it a child window
    label $w.t -text {Font Selector}
    pack $w.t -anchor w -side top

    set buts [frame $w.buts]
    pack $buts -side bottom -fill x -expand yes
    button $buts.can -text Cancel -command "destroy $w"
    button $buts.ok -text OK -command "set pref::font(ok) 1" -borderwidth 4 -pady 1
    pack $buts.can $buts.ok -side left -expand yes -fill x

    lassign $v font(fam) font(size) font(style)
    set b [frame $w.body]
    pack $b -side bottom -fill x -expand yes
    foreach {i j} {hel Helvetica cou Courier tim Times} {
        radiobutton $b.$i -text $j -variable pref::font(fam) -value $j -command pref::updfont
        pack $b.$i -side top -anchor w
    }
    frame $b.s; pack $b.s -side top -expand yes -fill x
    label $b.s.t -text Size:
    entry $b.s.size -textvariable pref::font(size) -width 4
    pack $b.s.t $b.s.size -side left -anchor w
    bind $b.s.size <Return> pref::updfont
    foreach {i j} {roman {} bold bold italic italic bold/italic {bold italic}} {
        radiobutton $b.$i -text $i -variable pref::font(style) -value $j -command pref::updfont
        pack $b.$i -side top -anchor w
    }
    
    frame [set body $w.b] -borderwidth 2 -relief raised
    place_near $w -40 20
    set font(ok) 0
    updfont
    tkwait variable pref::font(ok)
    if {[updfont]} {set v "$font(fam) $font(size) $font(style)"}
    destroy $w
}

# Edit global Preferences
# w:	The name we will give this toplevel
#------------------------------------------
proc pref::edit {{priv {}}} {
    variable cfig
    variable vals

    if {$priv == {}} {set priv $::cnf(appname)}
    set w .pref_$priv
    set rcfile $cfig(rcfile.$priv)
    set title $cfig(title.$priv)
    set defs $cfig(defs.$priv)
    if {[catch {toplevel $w -class Pref}]} {raise $w; return}
    
    wm transient $w [winfo parent $w]	;#make it a child window
    label $w._l_ -text $title
    pack $w._l_ -anchor w -side top

    set buts [frame $w.buts]
    pack $buts -side bottom -fill x -expand yes
    button $buts.geo -text Geom -command "pref::geoms $priv" -help {Grab all current settable window geometries}
    button $buts.app -text Apply -command "pref::apply $w $priv \{$defs\}" -help {Apply these values to the running program}
    button $buts.can -text Close -command "destroy $w" -help {Close this window}
    button $buts.sav -text Save -command "pref::apply $w $priv \{$defs\}; pref::save_file $rcfile \{$defs\}; destroy $w" -borderwidth 4 -pady 1 -help {Save these values for the next time the program is run}
#    bind $w <Return> "$buts.sav invoke"
    if {$priv != {global}} {pack $buts.geo -side left -fill x -expand yes}
    pack $buts.app $buts.can $buts.sav -side left -fill x -expand yes

    #make one of each type of widget to get option defaults
    foreach q {button canvas checkbutton entry frame label listbox menubutton menu message radiobutton scale scrollbar text} {
        $q $w.__$q
    }

    frame [set body $w.b] -borderwidth 2 -relief raised
    pack $body -fill both
    set n 0
    frame $w.f; pack $w.f -side top -fill both
    foreach rec $defs {
#puts "rec:$rec"
        argproc ca(\$s) [lassign $rec tag type title vname] $cfig(f_as)
        if {[llength $vname] > 1} {		;#if option
            lassign $vname oswitch ospec odeft
            set vals($tag) [$w.__$odeft cget -$oswitch]
        } else {
            set vals($tag) [subst \$$vname]
        }
        if {$type == {inv}} continue
        switch $type {
            ent {
                eval entry $w.f.e_$tag -relief sunken -textvariable pref::vals($tag) $ca(native)
                label $w.f.l_$tag -text $title -anchor e -padx 10
                if {[llength $ca(geom)] == 1} {
                    bind $w.f.e_$tag <Button-3> "set pref::vals($tag) \[pref::curgeom $ca(geom)\]"
                    bind $w.f.e_$tag <Shift-Button-3> "set pref::vals($tag) \[pref::curgeom $ca(geom) 1\]"
                    $w.f.e_$tag configure -help "Right-click to grab current window sizing\nShift-right-click to grab current window size and placement"
                }
            }
            pro {
                eval entry $w.f.e_$tag -relief sunken -textvariable pref::vals($tag) $ca(native)
                button $w.f.l_$tag -text $title -command "set pref::vals($tag) \[eval $ca(command)\]" -anchor e -pady 1
            }
            clr {
                eval entry $w.f.e_$tag -relief sunken -textvariable pref::vals($tag) $ca(native)
                button $w.f.l_$tag -text $title -command "pref::getcolor pref::vals($tag) $w.f.l_$tag" -anchor e -pady 1
                if {$vals($tag) != {}} {$w.f.l_$tag configure -bg $vals($tag)}
            }
            fnt {
                eval entry $w.f.e_$tag -relief sunken -textvariable pref::vals($tag) $ca(native)
                button $w.f.l_$tag -text $title -command "pref::getfont $w pref::vals($tag)" -anchor e -pady 1
            }
            geo {
#OBSOLETE
#                set oargs [lassign $oargs parent]
#                eval entry $w.f.e_$tag -relief sunken -textvariable pref::vals($tag) $oargs
#                button $w.f.l_$tag -text $title -command "set pref::vals($tag) \[pref::curgeom $parent $tag\]" -anchor e -pady 2
            }
            chk {
                eval checkbutton $w.f.e_$tag -variable pref::vals($tag) -width 6 -anchor w $ca(native)
                label $w.f.l_$tag -text $title -anchor e -padx 10
            }
            pdm {
                label $w.f.l_$tag -text $title -anchor e -padx 10
                eval menubutton $w.f.e_$tag -textvariable pref::vals($tag) -relief raised -padx 1 -pady 1 -anchor w -menu $w.f.e_$tag.m -indicatoron yes $ca(native)
                menu $w.f.e_$tag.m
                foreach mi $ca(menu) {
                    lassign $mi mcod mtit
                    $w.f.e_$tag.m add command -label "$mcod - $mtit" -command "set pref::vals($tag) \"$mcod\""
                }
            }
            default {error "Unknown preferences field type: $type"}
        }
        if {$ca(help) != {}} {$w.f.e_$tag configure -help "$ca(help)"}
        grid $w.f.l_$tag -row $n -column 0 -sticky e
        grid $w.f.e_$tag -row $n -column 1 -sticky w
        incr n
#puts "vname:$vname var:vals($tag)"
     }
    place_near $w -40 20		;#place our toplevel near cursor
}
