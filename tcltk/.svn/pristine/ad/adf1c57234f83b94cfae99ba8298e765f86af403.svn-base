#Routines common to noedit, ledit, etc.

if {[info commands cleanup] == {}} {proc cleanup {} {lout::cleanup}}

#Change the characteristics of the selected text
#------------------------------------------
proc chng_tags {tagnam} {
    global cnf
#    puts "[$::T curselection]"
    set tagtyp [csubstr $tagnam 0 1]
    lassign [$::T tag ranges sel] start stop
#    puts "tagnam:$tagnam start$start stop:$stop"
    if { "$tagtyp" == "x" } {		;# if removing all tags
    	foreach k $cnf(tagtypes) {
            foreach i $cnf(tagnams.${k}) {$::T tag remove $i $start $stop}	;#remove old tags
    	}
        return
    }
    foreach i $cnf(tagnams.${tagtyp}) {$::T tag remove $i $start $stop}	;#remove old tags of this type
    if {"$tagnam" != "${tagtyp}_norm"} {$::T tag add $tagnam $start $stop}	;#apply new tag
    set_modif
}

#Text now modified / unmodified
#------------------------------------------
proc set_modif {} {.menu.file.m entryconfigure 1 -state normal}
proc clr_modif {} {.menu.file.m entryconfigure 1 -state disabled}
proc is_modif {} {return [expr ![string compare [.menu.file.m entrycget 1 -state] normal]]}
    
#Check all keys to see if they modify things
#------------------------------------------
proc key_proc {key} {
    after idle {set ::cnf(curidx) [$::T index insert]}
}

# Exit program
#------------------------------------------
proc quit {{ask 1}} {
    global cnf
    if {$ask && [is_modif] && $cnf(rwstate) != {ro}} {
        set res [dia::ask "Warning:\nFile has been changed." {} 2 {Abandon Changes and Quit} {Save File and Quit} {Don't Quit}]
        switch $res {
            1	{editrw::save_file $::T}
            2	{return}
        }
    }
    cleanup		;#kill any leftover gv's or other cleanup
    exit
}

#Configure the main text window
#------------------------------------------
proc config_main {} {
    set font [$::T cget -font]
#    $::T tag configure s_norm	-font $font
    $::T tag configure s_bold	-font "$font bold"
    $::T tag configure s_italic	-font "$font italic"
    $::T tag configure s_bital	-font "$font bold italic"

#standard emphasis styles
#    $::T tag configure e_norm -underline off
    $::T tag configure e_under -underline on

    $::T configure -height 100 -width 180
}

# Make sure the text window has one and only one LF at the end
#------------------------------------------
proc check_lf {} {
    global cnf
#puts "[$::T index end-1c]"
    for {set i 2} {[$::T index end-1c] != 1.0} {incr i} {
#puts "i:$i dump:[$::T dump -text -window -tag end-${i}c end-1c]"
        set text {}
        foreach {j k l} [$::T dump -text -window -tag end-${i}c end-1c] {
#puts "  j:$j: k:$k: l:$l:"
            if {$j == {text}} {append text "$k"} else {append text {X}}
        }
#puts "  Text:$text:"
        if {$text != {} && ![string is space -strict $text]} break
#gets stdin
    }
#puts "I:$i"
    if {$i > 1} {$::T delete end-[expr $i - 2]c end}	;#nuke any trailing spaces
    $::T insert end "\n"		;#add a LF back in
}

#Create parts of the main window
#------------------------------------------
proc main_parts {args} {
    global cnf

    argproc ca(\$s) $args {{edit 1} {etws 1} {fmt 1} {help 1} {search 1} {tools 1} {prcmd do_print} {pvcmd do_prev}}
    wm iconname . $cnf(title)
    wm title . $cnf(title)
    wm geometry . $cnf(geom)

#Make menu bar across the top
    set mu .menu
    frame $mu -relief raised -borderwidth 2		;#menu bar
    pack $mu -side top -fill x -expand yes

#File menu list
    menubutton $mu.file -text File -menu $mu.file.m -under 0
    menu [set m $mu.file.m]
    $m add command -label {Save File}	-command {editrw::save_file $::T} -accelerator A-S -under 0
    $m entryconfigure 1 -state disabled
    $m add command -label {Save File As} -command {editrw::save_to_file $::T {}} -under 1
    $m add command -label {Load File}	-command {editrw::load_file $::T} -accelerator A-O -under 0
    $m add command -label {Insert File}	-command {editrw::load_file $::T {} -clear no -setcur 0}
    $m add command -label {Clear Workspace}	-command {clear_all}
    $m add separator
    $m add cascade -label {Import}  -menu $m.imp
    $m add cascade -label {Export}  -menu $m.exp
    $m add separator
    if {$ca(prcmd) != {}} {$m add command -label {Print} -command $ca(prcmd) -accelerator A-P -under 0}
    if {$ca(pvcmd) != {}} {$m add command -label {Preview} -command $ca(pvcmd) -under 3}
    $m add separator
    $m add command -label {Application Preferences} -command "pref::edit"
    $m add command -label {Global Preferences} -command "pref::edit global"
    $m add separator
    $m add command -label {Exit} -command quit -accelerator A-Q
    pack $mu.file -side left -padx 10
    bind . <Alt-s> {editrw::save_file $::T}
    bind . <Alt-o> {editrw::load_file $::T}
    bind . <Alt-q> {quit}
    bind . <Alt-p> {do_print}

    menu $m.imp -tearoff no
    $m.imp add command -label {Insert File}	 -command {editrw::load_file $::T {} -clear no -setcur no}
    $m.imp add command -label {Import Text}	 -command {editrw::import_file $::T {}}
    $m.imp add command -label {Import Formatted} -command {editrw::import_file $::T {} -fmt yes}

    menu $m.exp -tearoff no
    $m.exp add command -label {Export Text}	 -command {editrw::export_file $::T {}}
    $m.exp add command -label {Export Formatted} -command {editrw::export_file $::T {} -fmt yes}

#Edit menu
    cpctpa .menu.edit
    .menu.edit.m add separator
    .menu.edit.m add command -label {Undo} -command {$::T undo} -accelerator A-Z -under 0
    .menu.edit.m add command -label {Redo} -command {$::T redo} -accelerator A-Y -under 0

    if {$ca(fmt)} {
        menubutton $mu.text -text Text -menu $mu.text.m -under 2
        help::init $mu.text {Change characteristics of the text in the document}
        menu [set m $mu.text.m]
        foreach typ $cnf(tagtypes) {
            foreach nam $cnf(tagnams.${typ}) lab $cnf(taglabs.${typ}) {
                $m add command -label $lab -command "chng_tags $nam"
            }
            $m add separator
        }
        $m add command -label {All Normal} -command {chng_tags x_norm} -under 4
        pack $mu.text -side left -padx 10
    }

    if {$ca(etws)} {
        menubutton $mu.insr -text Insert -menu $mu.insr.m -under 0
        help::init $mu.insr {Insert special features into the document}
        menu [set m $mu.insr.m]
        foreach i $cnf(etws) {
            lassign $i tag title
            $m add command -label $title -command "etw${tag}::create $::T"
        }
        pack $mu.insr -side left -padx 10
    }

    if {$ca(help)} {
        help::help $mu.help -appname $cnf(appname) -version $cnf(title)
    }

    if {$ca(help)} {tsearch::tsearch $mu.srch $::T; pack $mu.srch -side right}

    if {$ca(tools)} {
        menubutton $mu.tool -text Tools -menu $mu.tool.m -under 0
        pack $mu.tool -side left -padx 10
        menu [set m $mu.tool.m]
        $m add command -label {Spell Text Only} -command {spell::spell $::T -modif set_modif}
        $m add command -label {Spell All} -command {spell::spell $::T -modif set_modif -subwcmd etw::splist}
    }
    return $mu
}

# Center box holds main body text and scroll bars
#------------------------------------------
proc main_edit {args} {
    global cnf
    
    argproc ca(\$s) $args {{wrap word} {wincreate etw::create} {mod set_modif} {text 0}}
    frame [set m .bdy] -class Edit
    stext::text $::T -xscroll "$m.xs set" -yscroll "$m.ys set" -wrap $ca(wrap) -wincreate $ca(wincreate) -mod $ca(mod)
    scrollbar $m.xs -command "$::T xview" -orient h
    scrollbar $m.ys -command "$::T yview"
    if {$ca(wrap) != {word}} {pack $m.xs -side bottom -fill x}
    pack $m.ys $::T -side right -fill y
    bind Text <Alt-p> {}			;#remove their default functions
    bind Text <Alt-o> {}
    bind Text <Alt-s> {}
    focus $::T				;#initial focus on main window
    bind $::T <Key> {key_proc %A}		;#call on each key press
    bind $::T <ButtonRelease-1> {key_proc {}}	;#call on each button press
#    bind $::T <Delete> $ca(mod)
#puts "bind:[bindtags .]:[bindtags $::T]"
#    bindtags $::T ". Text $::T"		;#no all in bindtags

    editrw::init $::T -clrmod "$::T clearundo; clr_modif" -setmod $ca(mod) -hfields $cnf(hfields) -hanam cnf -natext $cnf(natext) -subwcmd {etw::create $w.$k end $d} -dumpcmd {etw${typ}::dump $k} -clearcmd {clear_all} -text $ca(text)
    return $m
}
