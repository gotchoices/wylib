package provide wylib 0.20	;#Oct 2001
#New and improved Database record previewer.
#This is designed to be used with dbe.  It will preview a bunch of records in
#a listbox and allow the user to select one to be edited in the dbe widget.
#------------------------------------------
#Copyright (C) 1999-2001 Wyatt-ERP LLC.  All other rights reserved.
#This program is free software. You can redistribute it and/or modify it under the terms of the Open Public License as published by PIC Development Group and the Open Solutions Group.
#The program is distributed with the hope that it will be useful and beneficial, but WITHOUT ANY WARRANTY, without even the implied warranty of MERCAHANTABILLITY or FITNESS FOR A PARTICULAR PURPOSE. See the license agreement for further details.
#You should have received a copy of the Open Public License along with this program. If you did not, please visit www.open-solutions.org to obtain a copy.
#TODO:
#- how to handle asc/desc when multiple sort fields specified
#- 

#option add *Dbp.Listbox.font {Courier 12} widgetDefault
option add *Dbp.Listbox.width 200 widgetDefault
#option add *Dbp.Listbox.background {#eeeeee} widgetDefault
option add *Dbp.lb.height 80 widgetDefault
#option add *Dbp.highlight orange widgetDefault
#option add *Dbp*Entry.background {#f0f0f0} widgetDefault
option add *Dbp.borderWidth 0 widgetDefault

namespace eval dbp {
    namespace export dbp
    variable cfig		;#config values for each widget
    variable v			;#variable values for each widget
    variable lq			;#keep details of latest query
    variable pk			;#primary keys for the current list

    set cfig(as) {{ewidget {}} {selectmode browse} {eproc {}} {pkey {}} {kdelim {-}} {header {}} {butside bottom} {see 0} {count {Cnt:}} {format {}} {search {FS>> <<BS}} {dohead 1} {aux {}} {title {}} {selmod {}} {fields {}} {qfields {}} {table {}} {where {}} {and {}} {preord {}} {order {}} {ascdes asc} {pstord {}} {help {}} {preload {}} {pstload {}} {pstsel {}} {autot Auto:} {revt Rev:} {autoload 0} {load 0} {gman pack} {gmc.ti {-side top -expand yes -fill both}} {gmc.tf {-side left}} {gmc.af {-side right}} {gmc.bf {-side bottom -expand yes -fill x}} {fl_gman pack} {fl_gmc {-side right}} {bf_gman pack} {bf_gmc {-side top -expand yes -fill x}} {bu_gman pack} {bu_gmc {-side left -expand yes -fill x}} {b {} {b_add \$w $v}} {f {} {f_add \$w $v}} {borderwidth 2} {relief raised} {native {borderwidth relief}} {* {} {lappend cfig(\$w:native) $s; set dummy \{$v\}}}}
    set cfig(f_as) {{title {}} {format {}} {qf {}} {table {$cfig($w:table)}} {native {}} {{*} {} {lappend cfig(\$w.\$ftag:native) $s; set dummy \{$v\}}}}
    set cfig(b_as) {{hide 0} {help {}} {pre {}} {pst {}} {s {}} {gman $cfig($w:bu_gman)} {gmc $cfig($w:bu_gmc)} {hotkey {}} {menu {}} {radio {}} {lblist {}} {radvar {}} {command {}} {native {command}} {{*} {} {lappend cfig(\$w\$bname:native) $s; set dummy \{$v\}}}}

    set cfig(hot:load) {Ctrl-s}
    set cfig(help:loadby) {Load the preview window with records by some search criteria}
    set cfig(help:ordby) {Select field(s) by which records are ordered in preview window}
    set cfig(help:prvrec) {Load the previous record in the preview window}
    set cfig(help:nxtrec) {Load the next record in the preview window}
    set cfig(help:load) {Load the preview window by its default selection criteria}
    set cfig(help:reload) {Load the preview window by the same criteria as used in the last load}
}

#Search for a string in the preview listbox
#w:	name of the preview widget
#pat:	string to search for
#args:
#    back:	search backwards
#    prompt:	ask for a match pattern
#------------------------------------------
proc dbp::search {w pat args} {
    variable cfig
    variable v

    set lb $w.lb
    argproc ca(\$s) $args {{prompt no} {pat {}} {back {no}} {from {}}}

    if {$ca(prompt)} {
        if {[dia::query {Search for:} pat 0 OK Cancel] > 0} {return}
    }
    if {$pat == {}} return
    if {![lcontain $v($w:srchhist) $pat]} {set v($w:srchhist) [linsert $v($w:srchhist) 0 $pat]}
#puts "hist:$v($w:srchhist)"
    if {$ca(from) != {}} {
        set line $ca(from)
    } elseif {[set sels [$lb curselection]] != {}} {	;#use currently selected line
        set line [lindex $sels 0]
    } else {
        set line [$lb index active]		;#or active line
    }
    if {$ca(back)} {set inc -1} else {set inc 1}
    for {set i [expr $line + $inc]} {$i < [$lb index end] && $i >= 0} {incr i $inc} {
#puts "i:$i cline:[$lb get $i]"
        if {[regexp -nocase -- $pat [$lb get $i]]} {
#           if {$i >= [$lb index end]} {set line [$lb index end]}	;#go to end on last search?
            $lb selection clear 0 end; $lb selection set $i
            $lb activate $i
            $lb see $i
            return
        }
    }
    $lb see $line
    dia::brief {Not found} 500
}

#Activate a certain line in the listbox
#------------------------------------------
proc dbp::goto {w val args} {
    variable v
    set lb $w.lb
    argproc ca(\$s) $args {{rel no}}
    if {$ca(rel)} {
        if {[set sels [$lb curselection]] != {}} {	;#use currently selected line
            set line [lindex $sels 0]
        } else {
            set line [$lb index active]		;#or active line
        }
        set val [expr $line + $val]
    }
    if {$val > [$lb index end]} {set val {end}}
    if {$val < 1} {set line 1}
    $lb selection clear 0 end; $lb selection set $val
    $lb activate $val
    $lb see $val
}
    
#Return the index(es) of the currently selected/active line(s) in the box
#------------------------------------------
proc dbp::curidx {w} {
    set lb $w.lb
    if {[set sels [$lb curselection]] == {}} {
        return [$lb index active]
    } elseif {[llength $sels] == 1} {
        return [lindex $sels 0]
    }
    return $sels
}

#Return the currently selected/active line in the box
#------------------------------------------
proc dbp::curline {w} {
    return [$w.lb get [lindex [curidx $w] 0]]
}

#Return the primary keys of all selected lines
#------------------------------------------
proc dbp::pklist {w {all 0}} {
    variable v
    variable pk
    set ids {}
#    foreach i [curidx $w] {lappend ids $pk($w:$i)}
    if {$all} {
        for {set i 0} {$i < $v($w:count)} {incr i} {lappend ids $pk($w:$i)}
    } else {
        foreach i [$w.lb curselection] {lappend ids $pk($w:$i)}
    }
    return $ids
}

#Load the data for the selected record into the entry widget
#line:	an optional index into the listbox to load	
#------------------------------------------
proc dbp::llbrec {w {line {}}} {
    variable cfig
    variable v
    variable pk

    set lb $w.lb
    if {$v($w:count) <= 0} {
        if {$cfig($w:ewidget) != {}} {$cfig($w:ewidget) clear -prompt no}
        return
    }
    if {$line != {}} {set idx [$lb index $line]} else {set idx [curidx $w]}
    set v($w:lastline) $idx		;#tell outside world which line
    if {[lcontain {browse single} $cfig($w:selectmode)]} {
        $lb selection clear 0 end; $lb selection set $idx
        $lb activate $idx
#        $lb see $idx
        set id $pk($w:$idx)
        set cmd "$cfig($w:eproc) \{$id\} $idx"
    } else {
        set ids {}; foreach i $idx {lappend ids $pk($w:$i)}
        set cmd "$cfig($w:eproc) \{$ids\} \{$idx\}"
        set id [lindex $ids 0]
    }
#puts "cmd:$cmd"
    
    if {$cfig($w:eproc) != {}} {lib::cwatch $lb; eval $cmd; lib::cnorm $lb}
    if {$cfig($w:ewidget) != {}} {
#puts "$cfig($w:ewidget) ldrec $id"
        $cfig($w:ewidget) ldrec $id	;#call the edit widget
    }
    if {[info exists cfig($w:pstsel)]} {eval $cfig($w:pstsel)}
}

#Load the next/prev record after the one selected in the listbox
#w:	name of the widget
#inc:	increment value 1 or -1
#------------------------------------------
proc dbp::nxtrec {w {inc 1}} {
    set lb $w.lb
    set line [curidx $w]
    incr line $inc
    if {$line >= [$lb index end] || $line < 0} {return 0}
    $lb selection clear 0 end
    $lb selection set $line
    $lb activate $line
    $lb see $line
    $w llbrec				;#load that record
    return 1
}

#Load the prev record before the one selected in the listbox
#w:	name of the widget
#------------------------------------------
proc dbp::prvrec {w} {nxtrec $w -1}

# Clear the preview box
#w:	name of the widget
#------------------------------------------
proc dbp::clear {w} {
    variable v
    $w.lb delete 0 end
    $w.lb activate 0
    set v($w:count) 0
}

proc dbp::load {w args} {clear $w; eval genload $w 1 $args}
proc dbp::reload {w args} {eval genload $w 0 -autoload $dbp::cfig($w:autoload) $args}

#Low level load routine
#------------------------------------------
proc dbp::genload {w defs args} {
    variable cfig
    variable lq
    variable v
    variable pk

    if {!$defs && ![info exists lq($w:autosel)]} {set defs 1}
    argproc lq($w:\$s) $args {{selmod $cfig($w:selmod)} {fields $cfig($w:qfields)} {table $cfig($w:table)} {where $cfig($w:where)} {and $cfig($w:and)} {preord $cfig($w:preord)} {order $cfig($w:order)} {pstord $cfig($w:pstord)} {ascdes $cfig($w:ascdes)} {autosel yes} {autoload $cfig($w:autoload)} {see $cfig($w:see)}} $defs
#puts "LQ:$lq($w:where):$lq($w:order):autoload:$cfig($w:autoload):$lq($w:autoload):"
    if {$cfig($w:preload) != {}} {if {![eval $cfig($w:preload)]} return}
    set lb $w.lb
    
    if {[set sels [$lb curselection]] != {}} {set line [lindex $sels 0]} else {set line [$lb index active]}	;#remember which line we were on
    set yview [lindex [$lb yview] 0]
    $lb delete 0 end

    if {$lq($w:where) == {} && $lq($w:and) == {}} {
        set lq($w:whand) {}
    } elseif {$lq($w:where) == {} && $lq($w:and) != {}} {
        set lq($w:whand) "where $lq($w:and)"
    } elseif {$lq($w:where) != {} && $lq($w:and) == {}} {
        set lq($w:whand) "where $lq($w:where)"
    } else {
        set lq($w:whand) "where ($lq($w:and)) and ($lq($w:where))"
    }
    set t0 [lindex $lq($w:table) 0]		;#first table
    if {[llength $t0] <= 1} {set alias {}} else {set alias [lindex $t0 1].}
    set kflds {}; set kvals {}; set knams {}; set i 0
#puts "pkey:$cfig($w:pkey):"
    foreach kf $cfig($w:pkey) {
        lappend kflds "$alias$kf as _pk_$kf"
        lappend knams "k$i"
        append kvals " \$k$i"
        incr i
    }
    
    if {$lq($w:order) != {}} {set order "order by [join $lq($w:order) " $lq($w:ascdes), "] $lq($w:ascdes)"} else {set order {}}
    set lq($w:command) "select $lq($w:selmod)"
    set lq($w:target) "from [join $lq($w:table) {,}]"
    set lq($w:spec) "[subst "$lq($w:whand) $lq($w:preord) $order $lq($w:pstord)"]"
    set query "$lq($w:command) [join [concat $kflds $lq($w:fields)] {,}] $lq($w:target) $lq($w:spec)"
#puts "query:$query"
    lib::cwatch [winfo toplevel $w]
    set pgres [sql::exe $query]		;#do the query
    set cnt [pg_result $pgres -numTuples]	;#how many recs did we get
    set v($w:count) $cnt			;#show how many records we got
    for {set i 0} {$i < $cnt} {incr i} {	;#load them into the listbox
        set res [pg_result $pgres -getTuple $i]
#puts "res:$res ev:format \{$cfig($w:format)\} $res"
        set res [eval lassign \{$res\} $knams]
#puts "res:$res k0:$k0 kvals:$kvals"
        set pk($w:$i) [eval list $kvals]
#puts "PK:$pk($w:$i)"
        if {[catch {set tstrg [eval "format \{$cfig($w:format)\} $res"]} errmsg]} {
            dia::err "Error formatting line: $res\n$errmsg"
            set tstrg $res
        }
        $lb insert end $tstrg			;#put it in the window
    }
    pg_result $pgres -clear
    lib::cnorm
    if {$line != 0} {
        $lb yview moveto $yview
        $lb see $line			;#make our original line visible
        $lb activate $line		;#activate it
    } elseif {$lq($w:see) != {}} {
        $lb see $lq($w:see)
    }
    if {$lq($w:autosel)} {
        $lb selection set $line		;#and select it
    }
    if {$lq($w:autoload)} {llbrec $w}		;#and load it
#    if {$lq($w:see) != {}} {$lb see $lq($w:see)}
    if {$cfig($w:dohead)} {
        $w.h delete 0 end
        $w.h insert end [eval format \{$cfig($w:format)\} $cfig($w:header)]
    }
    if {[info exists cfig($w:pstload)]} {eval $cfig($w:pstload)}
}

#Return a command line for making a search widget associated with this preview
#------------------------------------------
proc dbp::lblist {w} {
    variable cfig
    if {$cfig($w:and) != {}} {set ret "-link {$cfig($w:and)}"} else {set ret {}}
    foreach t $cfig($w:table) {
    append ret " -tab {{$t}}"
    }
    set i 0; foreach ft $cfig($w:fields) {
        append ret " -f \{$ft \{[lindex $cfig($w:header) $i]\}\}"
        incr i
    }
#puts "dbp::lblist:$ret"
    return $ret
}

#Configure a field
#------------------------------------------
proc dbp::f_config {w ftag args} {
    variable cfig
    argproc cfig($w.$ftag:\$s) $args $cfig(f_as) 0
#puts "ftag:$ftag args:$args format:$cfig($w.$ftag:format)"
    lassign {} cfig($w:qfields) cfig($w:format) cfig($w:header)
    foreach fn $cfig($w:fields) {
        lappend cfig($w:qfields) $cfig($w.$fn:qf)
        append cfig($w:format) $cfig($w.$fn:format)
        lappend cfig($w:header) $cfig($w.$fn:title)
    }
#puts "header:$cfig($w:header)"
#puts "format:$cfig($w:format)"
}

#Return the configuration switches for a field
#------------------------------------------
proc dbp::f_cget {w ftag option} {
    variable cfig
    set fn $w.$ftag
    if {![catch {set v [$fn cget $option]}]} {	;#if native
        return $v
    }
    return $cfig($fn:$option)
}

#Add a field into a dbp widget
#------------------------------------------
proc dbp::f_add {w ftag args} {
    variable cfig
    set args [lassign $args fmt title]
    if {$title == {}} {set title [cap_first $ftag]}
    set args "[list -format "$fmt" -title "$title"] $args"
    set fn $w.$ftag
    if {$cfig($w:table) == {} && $cfig($w:ewidget) != {}} {set cfig($w:table) \{$dbe::cfig($cfig($w:ewidget):table)\}}
    argproc cfig($fn:\$s) $args $cfig(f_as)
    lappend cfig($w:fields) $ftag
#puts "PFT table:$cfig($w:table) ew:$cfig($w:ewidget)"
    set ft [sql::ft $cfig($fn:table) $ftag]
    if {$cfig($fn:qf) == {}} {
        if {$ft == {date} || $ft == {timestamp}} {set cfig($fn:qf) norm_date($ftag)} else {set cfig($fn:qf) $ftag}
    }
    lappend cfig($w:qfields) $cfig($fn:qf)
    append cfig($w:format) $cfig($fn:format)
    lappend cfig($w:header) $cfig($fn:title)
#puts "F_add w:$w ftag:$ftag args:$args qfields:$cfig($w:qfields)"
}

#Parse configuration switches for a button
#------------------------------------------
proc dbp::b_cpars {w btag args} {
    variable cfig

    set bname .b.$btag
    set bn $w$bname
    argproc cfig($bn:\$s) $args $cfig(b_as)
#puts "B_ARGS:$args btag:$btag info:[info commands $btag]"
    if {$cfig($bn:command) == {}} {	;#if user didn't specify a routine
        if {[info commands $btag] != {}} {
            set cfig($bn:command) "dbp::$btag $w"
        } elseif {$btag == {ordby}} {
            set cfig($bn:radvar) dbp::lq($w:order)
            if {$cfig($bn:radio) == {}} {set cfig($bn:radio) [dbe::oblist $cfig($w:ewidget) "$cfig($w:order) $cfig($w:fields)"]}
            set cfig($bn:command) "dbp::genload $w 0"
        }
    } else {
        regsub -all {%w} $cfig($bn:command) "$w" cfig($bn:command)
    }
    if {$cfig($bn:hotkey) == {} && [info exists cfig(hot:$btag)]} {
        set cfig($bn:hotkey) $cfig(hot:$btag)
    }
    if {$cfig($bn:help) == {} && [info exists cfig(help:$btag)]} {
        set cfig($bn:help) $cfig(help:$btag)
    }
#puts "B_CFIG:[array get cfig $bn:*]"
}

#Configure a button
#------------------------------------------
proc dbp::b_config {w btag args} {
    variable cfig

    eval b_cpars $w $btag $args
    eval $w.b.$btag configure [native dbp $w .b.$btag]	;#configure native stuff
#FIXME    help::init $w.b.$btag $cfig($w.b.$btag:help)
}

#Return the configuration switches for a button
#------------------------------------------
proc dbp::b_cget {w btag option} {
    variable cfig
    set bn $w.b.$btag
    if {![catch {set v [$bn cget $option]}]} {	;#if native
        return $v
    }
    return $cfig($bn:$option)
}

#Add a button into a dbp widget
#------------------------------------------
proc dbp::b_add {w btag args} {
    variable cfig
#puts "B_add w:$w btag:$btag args:$args bu_gman:$cfig($w:bu_gman)"
    set args [lassign $args text]
    set args "[list -text "$text"] $args"
    set bname .b.$btag
    set bn $w$bname
    eval b_cpars $w $btag $args

    if {$cfig($bn:s) != {}} {		;#if non-standard frame
        lappend cfig($bn:gmc) -in [set in $w.b.b$cfig($bn:s)]
        if {![winfo exists $in]} {lappend cfig($w:bframes) [frame $in]}
    }
    if {$cfig($bn:menu) != {}} {
        if {[set idx [lsearch [set nat [native dbp $w $bname]] -command]] >= 0} {set nat [lreplace $nat $idx [expr $idx + 1]]}
        eval menubutton $bn -menu [set m $bn.m] -relief raised -borderwidth 2 -pady 4 -indicatoron yes $nat
        menu $bn.m
        foreach rec $cfig($bn:menu) {
            lassign $rec tag title
            if {$title == {}} {set title [cap_first $tag]}
            if {[regexp -- {%t} $cfig($bn:command)]} {
                regsub -all {%t} $cfig($bn:command) "$tag" cmd
            } else {
                set cmd "$cfig($bn:command) $tag"
            }
            $m add command -label $title -command $cmd
        } 
    } elseif {$cfig($bn:radio) != {}} {
        eval menubutton $bn -menu [set m $bn.m] -relief raised -borderwidth 2 -pady 4 -indicatoron yes [native dbp $w $bname command]
        menu $bn.m
        if {$cfig($bn:radvar) == {}} {set cfig($bn:radvar) dbp::v($bn)}
        set $cfig($bn:radvar) [lindex [lindex $cfig($bn:radio) 0] 0]
        foreach rec $cfig($bn:radio) {
            lassign $rec tag title
            if {$title == {}} {set title [cap_first $tag]}
            $m add radio -label $title -variable $cfig($bn:radvar) -value $tag -command $cfig($bn:command)
        }
    } elseif {$btag == {loadby} || $cfig($bn:lblist) != {}} {
        if {$cfig($bn:lblist) != {}} {
            set lblist $cfig($bn:lblist)
        } elseif {$cfig($w:ewidget) != {}} {
            set lblist [dbe::lblist $cfig($w:ewidget)]
        } else {
            set lblist [dbp::lblist $w]
        }
        if {![regexp -- {-tab} $lblist]} {set lblist "-tab \{\{[lindex $cfig($w:table) 0]\}\} $lblist"}
#puts "lblist:$lblist"
        eval button $bn [native dbp $w $bname] -command \{dbs::dbs \[uwin .[translit . _ $w]_srch\] -title \{Search on: $cfig($w:title)\} -top 1 $lblist -pwidget $w\}
    } else {
        eval button $bn [native dbp $w $bname]
    }
#FIXME    if {$btag == {nxtrec} ||$btag == {prvrec}} {lib::b_repeat $bn -delay 250}
    bind $bn <Return> "$bn invoke"
    if {$cfig($bn:hotkey) != {}} {bind $w $cfig($bn:hotkey) "$bn invoke"}
    lappend cfig($w:buts) $bn
#    lappend cfig($w:btags) $btag
#FIXME    help::init $bn $cfig($bn:help)
}

#Scroll the header to match the scroll in the listbox
#------------------------------------------
proc dbp::scroll_hdr {h x1 x2} {$h xview moveto $x1}

#Create the preview listbox window
#------------------------------------------
proc dbp::dbp {w args} {
    variable cfig
    variable v
    variable lq

    catch {frame $w -class Dbp}		;#main frame for widget
    frame $w.t -relief raised -bd 1	;#title master frame
    frame $w.b				;#button master frame
    
    array set cfig "$w:buts {} $w:items {} $w:tframes {} $w:bframes {} $w.b.load:pre {} $w.b.load:pst {}"
    argproc cfig($w:\$s) $args $cfig(as)
    set v($w:srchhist) {}
#puts "CFIG:[array get cfig]"
#    if {$cfig($w:table) == {}} {error "No table defined"}
    if {$cfig($w:table) == {}} {if {$cfig($w:ewidget) != {}} {set cfig($w:table) $dbe::cfig($cfig($w:ewidget):table)} else {error "No table defined"}}
    if {$cfig($w:pkey) == {}} {if {$cfig($w:ewidget) != {}} {set cfig($w:pkey) $dbe::cfig($cfig($w:ewidget):pkey)} else {error "No primary key defined"}}
#puts "table:$cfig($w:table):  pkey:$cfig($w:pkey):"

    if {$cfig($w:title) != {}} {
        eval $cfig($w:gman) $w.t $cfig($w:gmc.ti)	;#title frame
        label $w.t.l -text $cfig($w:title)
#FIXME        help::init $w.t.l $cfig($w:help)
        eval $cfig($w:gman) $w.t.l $cfig($w:gmc.tf)
        
        if {$cfig($w:count) != {}} {		;#show current record count
            set entry [lassign $cfig($w:count) title]
            eval label $w.t.cl -text $title
            eval entry $w.t.ce -textvariable dbp::v($w:count) -width 5 -state disabled -borderwidth 1 $entry
            eval $cfig($w:gman) $w.t.ce $w.t.cl $cfig($w:gmc.af)
#FIXME            help::init $w.t.ce {How many records currently loaded}
        }
        if {$cfig($w:aux) != {}} {
            set entry [lassign $cfig($w:aux) title help]
            eval label $w.t.al -text $title
            eval entry $w.t.ae -textvariable dbp::v($w:aux) -borderwidth 1 $entry
            eval $cfig($w:gman) $w.t.ae $w.t.al $cfig($w:gmc.af)
#FIXME            if {$help != {}} {help::init $w.t.ae $help}
        }
        if {$cfig($w:search) != {}} {
            set entry [lassign $cfig($w:search) fwd rev]
            button $w.t.ss -text $fwd -command "dbp::search $w \$dbp::v($w:search)" -pady 0 -padx 1
#FIXME            help::init $w.t.ss {Start a forward search}
            button $w.t.sb -text $rev -command "dbp::search $w \$dbp::v($w:search) -back yes" -pady 0 -padx 1
#FIXME            help::init $w.t.sb {Start a reverse search}
            eval entry $w.t.se -textvariable dbp::v($w:search) -width 10 -bd 1 $entry
#FIXME            help::init $w.t.se {Search the preview pane for a word}
            eval $cfig($w:gman) $w.t.se $w.t.ss $w.t.sb $cfig($w:gmc.af)
#            bind $w.t.se <Key> "dbp::search $w \$dbp::v($w:search) -from 0"
            bind $w.t.se <Control-b> "dbp::search $w \$dbp::v($w:search) -from 0"
            bind $w.t.se <Return> "dbp::search $w \$dbp::v($w:search)"
#            bind $w.t.se <Control-s> "dbp::search $w \$dbp::v($w:search)"
            bind $w.t.se <Control-Return> "dbp::search $w \$dbp::v($w:search) -back yes"
            bind $w.t.se <Control-n> "dbp::nxtrec $w 1"
            bind $w.t.se <Control-p> "dbp::nxtrec $w -1"
#            bind $w.t.se <Return> "dbp::llbrec $w"
            bind $w.t.se <Control-s> "dbp::llbrec $w"
            bind $w.t.se <Control-c> "set dbp::v($w:search) {}; dbp::goto $w 0"
            bind $w.t.se <Up> "dbp::goto $w -1 -rel yes"
            bind $w.t.se <Down> "dbp::goto $w 1 -rel yes"
            bind $w.t.se <Button-3> "focus $w.t.se; scmenu::top .dbp[translit . _ $w] -dest $w.t.se -list \$dbp::v($w:srchhist) -height 10 -token all"
            bindtags $w.t.se "Entry $w.t.se ."
        }
        if {$cfig($w:autot) != {}} {
            label $w.t.ll -text $cfig($w:autot)
            checkbutton $w.t.lc -variable dbp::cfig($w:autoload)
#FIXME            help::init $w.t.lc {Cause the highlighted (first) record to be automatically selected}
            eval $cfig($w:gman) $w.t.lc $w.t.ll $cfig($w:gmc.af)
        }
        if {$cfig($w:revt) != {}} {
            label $w.t.ol -text $cfig($w:revt)
            checkbutton $w.t.oc -variable dbp::cfig($w:ascdes) -onvalue {desc} -offvalue {asc} -command "dbp::reload $w -ascdes \$dbp::cfig($w:ascdes)"
#FIXME            help::init $w.t.oc {Reverse the sorting order in the preview}
            eval $cfig($w:gman) $w.t.oc $w.t.ol $cfig($w:gmc.af)
        }
    }
    eval $cfig($w:gman) $w.b $cfig($w:gmc.bf)		;#button frame
    if {$cfig($w:bframes) != {}} {eval $cfig($w:gman) $cfig($w:bframes) $cfig($w:bf_gmc)}	;#pack button frames
    if {$cfig($w:tframes) != {}} {eval $cfig($w:gman) $cfig($w:tframes) $cfig($w:tf_gmc)}	;#pack title frames
    foreach a "$cfig($w:buts) $cfig($w:items)" {	;#pack buttons and items
        if {$cfig($a:hide)} {} else {eval $cfig($a:gman) $a $cfig($a:gmc)}
    }
    
    scrollbar $w.ys -orient vertical -relief sunken -command "$w.lb yview" 
    pack $w.ys -side right -fill y -expand yes
    listbox $w.h -relief flat -height 1 	;#-xscroll "dbp::scroll_hdr $w.lb"
    if {$cfig($w:dohead)} {pack $w.h -side top}
    listbox $w.lb -yscrollcommand "$w.ys set" -xscrollcommand "dbp::scroll_hdr $w.h" -selectmode $cfig($w:selectmode)
#puts "width:[option get $w.lb width Dbp]"
    pack $w.lb -side top
    bind $w.lb <Double-1> "dbp::llbrec $w"
    bind $w.lb <Control-Button-3> "print::print .dbppr[translit {.} {_} $w] \{cconcat \[join \[$w.lb get 0 end\] \"\n\"\] \"\n\"\} -cmd 1"

    eval $w configure [native dbp $w {}]		;#configure native stuff

    rename ::$w __$w		;#rename widget, make a new one in its place
    proc ::$w {command args} "namespace eval dbp widgcmd $w \$command \$args"	;#create widget proc
    set lq($w:where) $cfig($w:where)			;#init where,ord clauses
    set lq($w:order) $cfig($w:order)
    if {$cfig($w:load)} {genload $w 1}
}

#The widget command for the preview box widget
#w:		widget name
#command:	the basic command
#args:		the rest of the arguments
#------------------------------------------
proc dbp::widgcmd {w command args} {
    switch -exact $command {
        {v}		{return $dbp::v($w:$args)}
        {load}		{eval dbp::load $w $args}
        {reload}	{eval dbp::reload $w $args}
        {loadby}	{eval dbp::loadby $w $args}
        {llbrec}	{eval dbp::llbrec $w $args}
        {pklist}	{return [eval pklist $w $args]}
        {whand}		{return $dbp::lq($w:whand)}
        {curidx}	{return [curidx $w]}
        {curline}	{return [curline $w]}
        {nxtrec}	{return [nxtrec $w]}
        {prvrec}	{return [nxtrec $w -1]}
        {get}		{return [eval $w.lb get $args]}
        {clear}		{dbp::clear $w}
        {b_add}		{eval dbp::b_add $w $args}
        {b_name}	{return $w.b.[lindex $args 0]}
        {b_config}	{eval dbp::b_config $w $args}
        {b_invoke}	{$w.b.[lindex $args 0] invoke}
        {f_config}	{eval dbp::f_config $w $args}
        {t_frame}	{return $w.t}
        {print}		{dbp::print $w}
        {search}	{eval dbp::search $w $args}
        {goto}		{eval dbp::goto $w $args}
        {w}		{return $w}
        {default}	{return [eval __$w $command $args]}
    }
}
