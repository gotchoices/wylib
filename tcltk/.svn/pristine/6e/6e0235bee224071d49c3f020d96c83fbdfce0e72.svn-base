package provide wylib 0.20	;#Oct 2001
#Produce an interactive ER Diagram
#------------------------------------------
#Copyright (C) 1999-2003 Wyatt-ERP LLC.  All other rights reserved.
#This program is free software. You can redistribute it and/or modify it under the terms of the Open Public License as published by PIC Development Group and the Open Solutions Group.
#The program is distributed with the hope that it will be useful and beneficial, but WITHOUT ANY WARRANTY, without even the implied warranty of MERCAHANTABILLITY or FITNESS FOR A PARTICULAR PURPOSE. See the license agreement for further details.
#You should have received a copy of the Open Public License along with this program. If you did not, please visit www.opl.org to obtain a copy.
#TODO:
#X- Simulate several tables w/ primary and foreign keys
#X- Have "add" pull its own table information from database?
#X- Save/restore positions/sizes of tables on destroy
#X- Right-click menu when clicking on tables
#X- Generate PS of canvas
#X- Draw arrows between tables
#- Data structure to keep track of relational links
#- Rubber-band only affected arrows when tables dragged
#- Try native-canvas tables instead of mlb's
#- 

namespace eval erd {
    namespace export erd
    variable cfig
    variable v

    image create bitmap but -data "#define dot_width 7\n#define dot_height 7\nstatic unsigned char dot_bits[] = {\n0x08, 0x14, 0x2a, 0x55, 0x2a, 0x14, 0x08};"
}

#option add *Erd*Listbox.font fixed widgetDefault
#option add *Erd*Listbox.borderWidth 1 widgetDefault
option add *Erd.Canvas*Listbox.font {Fixed 8} 25	;#overcome Mlb defaults
option add *Erd.Canvas*Label.font {Helvetica 8} widgetDefault
option add *Erd.Canvas*Listbox.borderwidth 1 widgetDefault
option add *Erd.Canvas.Frame.relief raised widgetDefault
option add *Erd.Canvas.Frame.borderWidth 1 widgetDefault
option add *Erd.Canvas.Frame.Label.background #8080ff widgetDefault
option add *Erd.Canvas.Frame.Label.cursor dot widgetDefault
option add *Erd.Canvas.Frame.width 120 widgetDefault
option add *Erd.Canvas.Frame.height 240 widgetDefault

#Anytime the widget main frame is configured, reconfigure the canvas size to fill the frame
#--------------------------------
proc erd::p_config {w {wid {}} {hei {}}} {
    variable cfig

#puts "P Configure w:$w wid:$wid hei:$hei width:[winfo width $w] height:[winfo height $w]"
    if {$wid == {}} {set wid [winfo width $w]}
    if {$hei == {}} {set hei [winfo height $w]}
    set pw [expr $wid - [winfo width  $w.ys] - 2]	;#-2 is a kludge (how to know exactly?)
    set ph [expr $hei - [winfo height $w.xs] - 2]

    $w.c configure -width $pw -height $ph 	;#-scrollregion "0 0 $mw $ph"
}

# Prepare for a drag-n-drop
#--------------------------------
proc erd::start_drag {w x y} {
    variable v
    set v(lastx) [$w.c canvasx $x]
    set v(lasty) [$w.c canvasy $y]
puts "start: lastx:$v(lastx) lasty:$v(lasty)"
}

# Do the dragging
#--------------------------------
proc erd::drag {w t x y} {
    variable v
    set x [$w.c canvasx $x]
    set y [$w.c canvasy $y]
#puts "move: lastx:$v(lastx) lasty:$v(lasty) x:$x y:$y"
    $w.c move $t [expr $x - $v(lastx)] [expr $y - $v(lasty)]
    set v(lastx) $x
    set v(lasty) $y

    links $w $t		;#drag any outbound arrows
    set dunit $t
    foreach tag $v(linktags$w) {	;#and any inbound arrows
        if {[lcontain $v(link.$tag$w) $t] && ![lcontain $dunit $tag]} {
            links $w $tag
            lappend dunit $tag
        }
    }
}

#Print canvas
#--------------------------------
proc erd::print {w {tofile 0}} {
    variable cfig
    if {$tofile} {
        if {[sfile::top .erdexp -dest fname -title {Select a filename to export to} -op {Export to} -mask {*.ps} -wait 1] == {}} return
    } else {
        set fname [file join [lib::cfig workdir] "erd-tmp.ps"]
    }
puts "Printing postscript to: $fname"
    update
    lib::cwatch $w
    $w.c postscript -file $fname -width $cfig(width$w) -height $cfig(height$w) -pagewidth $cfig(pagewidth$w) -pageheight $cfig(pageheight$w)
    lib::cnorm $w
    if {!$tofile} {print::print .erdprint $fname}
}

# Compute the best (closest) end points for an arrow between two tables
#--------------------------------
proc erd::closest {w tab1 x1 y1 tab2 x2 y2} {
    upvar $x1 x1u $y1 y1u $x2 x2u $y2 y2u
    
    lassign [$w coords $tab1] t1x t1y	;#table 1 origin
    set t1w [$w.c.$tab1 cget -width]	;#width
    set t1h [$w.c.$tab1 cget -height]	;#height
    lassign [$w coords $tab2] t2x t2y	;#table 2 origin
    set t2w [$w.c.$tab2 cget -width]	;#width
    set t2h [$w.c.$tab2 cget -height]	;#height

    set x1m [expr $t1x + $t1w]		;#table 1 max coordinates
    set y1m [expr $t1y + $t1h]
    set x1i [expr $t1w / 2]		;#table 1 increment size
    set y1i [expr $t1h / 2]
    set x2m [expr $t2x + $t2w]		;#table 2 max coordinates
    set y2m [expr $t2y + $t2h]
    set x2i [expr $t2w / 2]		;#table 2 increment size
    set y2i [expr $t2h / 2]
    
    set min 10000000
    for {set x1t $t1x} {$x1t <= $x1m} {set x1t [expr $x1t + $x1i]} {
      for {set y1t $t1y} {$y1t <= $y1m} {set y1t [expr $y1i + $y1t]} {
        for {set x2t $t2x} {$x2t <= $x2m} {set x2t [expr $x2t + $x2i]} {
          for {set y2t $t2y} {$y2t <= $y2m} {set y2t [expr $y2i + $y2t]} {
            set dist [expr sqrt(pow($x1t - $x2t,2) + pow($y1t - $y2t,2))]
            if {$dist < $min} {
                lassign "$x1t $y1t $x2t $y2t" x1u y1u x2u y2u
                set min $dist
#puts "xt:$xt yt:$yt dist:$dist"
            }
          }
        }
      }
    }
}

# Draw the links between tables
#--------------------------------
proc erd::links {w args} {
    variable cfig
    variable v

#puts "args:$args"
    if {[llength $args] <= 0} {set args $v(linktags$w)}
    foreach tab1 $args {
        foreach tab2 $v(link.$tab1$w) {
    
#puts " tab1:$tab1 tab2:$tab2"
            closest $w $tab1 x1 y1 $tab2 x2 y2
            if {[llength [set id [$w.c find withtag "$tab1-link-$tab2"]]] <= 0} {	;#doesn't exist yet
                $w.c create line $x1 $y1 $x2 $y2 -tags "$tab1-link-$tab2" -arrow last
            } else {
                $w.c coords $id $x1 $y1 $x2 $y2
#puts " $w.c coords $id $x1 $y1 $x2 $y2"
            }
        }
    }
}

# Add a new table widget to the canvas
#--------------------------------
proc erd::add {w args} {
    variable cfig
    variable v
    argform {table title help x y} args
    argnorm {{table 2} {title 2} {help 2}} args
    if {[set table [xswitchs table args]] == {}} return
    set t $w.c.$table
    lassign {0 0} x y
    foreach s {title help} {set cfig($s$t) [xswitchs $s args]}
    foreach s {x y} {xswitchs $s args $s}

    frame $t
    $w.c create window $x $y -window $t -anchor nw -tags $table
    label $t.t -text "$table - $cfig(title$t)" -help $cfig(help$t)
    mlb::mlb $t.lb\
        -f {n 16 -just r -help {Field order}}\
        -f {column -help {Column tag name}}\
        -f {title -help {Column Description}}\
        -f {type}\
        -f {len 16 -just r -help {How many characters the column will hold}}\
        -f {nonull -help {True if the field can not be assigned to be NULL}}
    sizer::sizer $t.hz $t -o v
    sizer::sizer $t.vz $t -o h
    pack $t.hz -side right -fill y
    pack $t.vz -side bottom -fill x
    pack $t.t -side top -anchor w -fill x
    pack $t.lb -side top -fill both -exp 1

    eval $t.lb insert end [sql::qlist "select (case when ispkey then '*' else '' end)||text(field),columnname,title,type,length,nonull from wm.column_pub where tablename = '$table' and (language isnull or language = '$cfig(lang$w)') order by field"]

    bind $t.t <1> "erd::start_drag $w %X %Y"
    bind $t.t <B1-Motion> "erd::drag $w $table %X %Y"

#Using native canvas objects:    
#    set x 100
#    set y 100
#    $w.c create rect $x $y [expr $x + $width] [expr $y + $height + 2] -tags $tag -fill $color
#    $w.c create text [expr $x + 2] [expr $y + ($height/2) + 1] -text $table -tags $tag -anchor w
#    $w.c create line $x [expr $y + $height] [expr $x + $width] [expr $y + $height] -tags $tag
#    incr y [expr $height + 2]
#    for {set i 0} {$i < [llength $fields]} {incr i} {
#        $w.c create rect $x $y [expr $x + $width] [expr $y + $height] -tags $tag -fill $color
#        $w.c create text [expr $x + 2] [expr $y + ($height/2) + 1] -text [lindex $titles $i] -tags $tag -anchor w
#        incr y $height
#    }
}

# Yield/restore preferences
#------------------------------------------
proc erd::pref {w args} {
    variable cfig
    variable v
    if {[llength $args] <= 0} {
        lappend parr "configure -width [$w cget -width] -height [$w cget -height]"
        foreach tag $cfig(tags$w) {
            lappend parr "coords $tag [$w coords $tag]"
            lappend parr "table $tag frame configure -height [$w table $tag frame cget -height] -width [$w table $tag frame cget -width]"
            lappend parr "table $tag pref [$w table $tag pref]"
        }
#puts "Dump pref:$parr"
        return $parr
    } else {
        foreach cmd $args {
            if {$cmd != {}} {catch {eval $w $cmd}}
        }
    }
}

# Context menu
#------------------------------------------
proc erd::cmenu {w {tag {}}} {
    variable v
    set v(coltag$w) $tag
#puts "tag:$tag"
    lassign [winfo pointerxy .] x y
    tk_popup $w.m $x $y
}

# Add all tables from the database
#--------------------------------
proc erd::init {w args} {
    variable cfig
    variable v

#    argform {table} args
#    argnorm {{table 2} {title 2} {fields 2}} args
#    if {[set table [xswitchs table args]] == {}} return
#    set t $w.c.$table
#    foreach s {title fields} {set cfig($s$t) [xswitchs $s args]}
#    foreach s {} {xswitchs $s args cfig($s$t)}

    set cfig(tags$w) {}
    lassign {0 0} x y
#set and "and (tablename ~ 'vend.*' or tablename ~ 'empl.*' or tablename ~ 'priv.*')"
set and ""
    foreach rec [sql::qlist "select tablename,kind,title,help from wm.table_pub where kind = 'r' and (language isnull or language = '$cfig(lang$w)') $and"] {
#puts rec:$rec
        lassign $rec tablename kind title help
        add $w $tablename $title $help $x $y
        lappend cfig(tags$w) $tablename
        incr x 2
        incr y 2
        set v(link.$tablename$w) {}
    }

    set v(linktags$w) {}
    foreach rec [sql::qlist "select tablename,fktable from wm.table_keys where schemaname = 'public' and fktable != tablename $and order by 2"] {
        lassign $rec tablename fktable
#puts "rec:$rec"
        lappend v(linktags$w) $tablename	;#tables with fk references (outbound arrows)
        lappend v(link.$tablename$w) $fktable	;#who they point to
        links $w $tablename
    }
}

# Get configuration for an entry
#------------------------------------------
proc erd::cget {w option} {
    variable cfig
XXXXXXXX
    argnorm $cfig(swar) option
    set opt [string trimleft $option -]
    if {[lcontain {highlt sum} $opt]} {return $cfig($opt$w)}
    return [eval _$w cget $option]
}

# Configure an existing widget
#------------------------------------------
proc erd::configure {w args} {
    variable cfig
    if {$args == {}} {return [_$w configure]}
XXXXXXXX
    argnorm $cfig(swar) args
    foreach tag {highlt sum} {xswitchs $tag args cfig($tag$w)}
    if {$args != {}} {return [eval _$w configure $args]}
    return {}
}

# Constructor
#------------------------------------------
proc erd::erd {w args} {
    variable cfig
    variable v

    argnorm {{field 1 f} {frame 2 fr} {language 2 lang} {initialize 2 init} {width 2} {height 2} {pageheight 5} {pagewidth 5}} args
    array set cfig "lang$w en tags$w {} width$w 2000 height$w 2000 pagewidth$w 17i pageheight$w 11i"
#    foreach s {data} {set cfig($s$w) [xswitchs $s args]}
    foreach s {init lang width height pagewidth pageheight} {xswitchs $s args cfig($s$w)}

    lassign {} cols fr
    while {[xswitch f args va sw] != {}} {lappend cols $sw $va}	;#grab fields from cmdline
    while {[set x [xswitch fr args]] != {}} {append fr { } $x}

    set cfig(lbargs$w) $args
    array set v "master$w {} marked$w {}"

    if {[winfo exists $w]} {
        eval $w configure $fr
    } else {
        eval ww::_frame $w -class Erd $fr
        bind $w <Configure> {erd::p_config %W %w %h}
        widginit $w erd *$w
    }

    canvas $w.c -bg white -xscrollc "$w.xs set" -yscrollc "$w.ys set" -scrollregion "0 0 $cfig(width$w) $cfig(height$w)"
    scrollbar $w.xs -orient h -command "$w.c xview"
    scrollbar $w.ys -orient v -command "$w.c yview"
    button $w.b -image but -help {What does this do} -command "$w huh"
    grid $w.c $w.ys -row 0 -sticky news
    grid $w.xs $w.b -row 1 -sticky news
#    grid propagate $w no
#    p_config $w

    bind $w.c <Button-3> "erd::cmenu $w"

#    bind $w.c <1> "erd::start_drag $w %x %y"
#    bind $w.c <B1-Motion> "erd::drag $w %x %y"    

#Build widget menus
    menu $w.m
    $w.m add command ps -label {Postscript} -command "erd::print $w 1" -help {Generate a postscript file of the diagram}
    $w.m add command pr -label {Print} -command "erd::print $w" -help {Print the canvas to a file}

#    $w.m add cascade -label Column -menu $w.m.c -help {Perform operations on this column}
#    menu $w.m.c -tearoff no
#    $w.m.c add command au -label {Hide} -command "erd::hide $w \$erd::v(coltag$w)" -help {Remove this column from the display}

    if {[info exists cfig(init$w)]} {
        if {$cfig(init$w)} {init $w}		;#insert initial data
    }
}

# Pass a command to a table (pseudo widget)
#--------------------------------
proc erd::table {w tag args} {
    variable cfig
    set args [lassign $args cmd]
#puts "table:$w tag:$tag cmd:$cmd args:$args"
    set cmd [unabbrev {{title 2} {listbox 2} {frame 2}} $cmd]
    switch -exact -- $cmd {
        {title}	{return [eval $w.c.$tag.t $args]}
        {frame} {return [eval $w.c.$tag $args]}
        {listbox} {return [eval $w.c.$tag.lb $args]}
        {default} {return [eval $w.c.$tag.lb $cmd $args]}
    }
}

# Widget command
#------------------------------------------
proc erd::wcmd {w cmd args} {
    variable cfig
    variable v
#puts "wcmd:$w $cmd $args"
    set cmd [unabbrev {{frame 1} {add 2} {get 2} {initialize 2 init} {preference 3 pref}} $cmd]
    if {[lcontain {add get init pref links} $cmd]} {return [eval $cmd $w $args]}
    switch -exact -- $cmd {
        {w}		{return $w}
        {table}	{
            set args [lassign $args tag]
            if {[lcontain $cfig(tags$w) $tag]} {return [eval table $w $tag $args]}
            error "Invalid table: $tag"
        }
        {frame} {return [eval table _$w $args]}
        {default}	{
            if {[lcontain $cfig(tags$w) $cmd]} {
                return [eval table $w $cmd $args]
            } else {
                return [eval $w.c $cmd $args]
            }
        }
    }
}

#bind Erd <Leave>	{+help::leave %W}
#bind Erd <Motion>	{+help::motion %W}
