package provide wylib 0.20	;#Oct 2001
# Make a toplevel window for editing or viewing the contents of an entry
# or a variable
#------------------------------------------
#Copyright (C) 1999-2001 Wyatt-ERP LLC.  All other rights reserved.
#This program is free software. You can redistribute it and/or modify it under the terms of the Open Public License as published by PIC Development Group and the Open Solutions Group.
#The program is distributed with the hope that it will be useful and beneficial, but WITHOUT ANY WARRANTY, without even the implied warranty of MERCAHANTABILLITY or FITNESS FOR A PARTICULAR PURPOSE. See the license agreement for further details.
#You should have received a copy of the Open Public License along with this program. If you did not, please visit www.open-solutions.org to obtain a copy.
#TODO:
#- make window fit natural size but also allow stretching
#- 

#option add *Edwin*Text.background {#eeeeee} widgetDefault
option add *Edwin*Text.wrap none widgetDefault
option add *Edwin*Text.width 180 widgetDefault
option add *Edwin*Text.height 80 widgetDefault
option add *Edwin*Text.font {Courier 14} widgetDefault
option add *Edwin*Label.font {Helvetica 14 bold} widgetDefault

namespace eval edwin {
    namespace export edwin
    variable cfig		;#configuration values
    variable result		;#result values
    variable status		;#exit status
}

#Launch a command from the window
#------------------------------------------
proc edwin::launch {w} {
    variable cfig
    
    if {$cfig(launchcmd$w) == {}} return
    lassign [split [$w.t.text index insert] .] linenum col
    set line [$w.t.text get $linenum.0 $linenum.end]
#puts "linenum:$linenum line:$line"
    eval $cfig(launchcmd$w) \{$line\}
}

# Add a new button to edwin
#----------------------------------------------------
proc edwin::b_add {w tag title help args} {
    eval button $w.b.$tag -text \$title -help \$help $args
    pack $w.b.$tag -side left
}

# Save result of the session
#----------------------------------------------------
proc edwin::save {w} {
    variable cfig
    variable result
    variable status
    
    set newval [$w.t.text get 0.0 {end - 1 chars}]	;#get text
    if {$newval != $result($w) && $cfig(mod$w) != {}} {eval $cfig(mod$w)}	;#note modified
    set result($w) $newval
    
    if {$cfig(varname$w) != {}} {	;#if variable to receive result
        if {$cfig(wait$w)} {} else {	;#and it is a global
            set $cfig(varname$w) $result($w)
        }
    }
    if {$cfig(entry$w) != {}} {		;#if entry to receive result
        $cfig(entry$w) delete 0 end
        $cfig(entry$w) insert 0 $result($w)
    }
    if {$cfig(proc$w) != {}} {eval $cfig(proc$w)}
    destroy $w
    set status($w) {OK}
}

# Make a toplevel window for editing or viewing an event text
# w:	widget name
# args:	other arguments
#	entry	name of an entry to receive the result
#	varname	name of a variable to receive the result
#	mod	name of a routine to call when modifications made
#	rdonly	make the window read-only
#----------------------------------------------------
proc edwin::edwin {w args} {
    variable cfig
    variable result
    variable status

    set cfig(other$w) {}
    argproc cfig(\$s$w) $args {{init yes} {abort {Abort Edit}} {save {Done}} {entry {}} {varname {}} {title {Editing: $w}} {geom 640x400} {mod {}} {rdonly no} {curpos {}} {launchcmd {}} {launchlab {}} {see {}} {quit yes} {trans no} {wait no} {spell yes} {insert {}} {proc {}} {print yes} {printer P} {* {} {lappend cfig(other\$w) -$s \{$v\}}}}
    if {[winfo exists $w]} {destroy $w}
    toplevel $w -class Edwin
    wm title $w $cfig(title$w)
    if {$cfig(trans$w)} {wm transient $w [winfo parent $w]}
    if {$cfig(geom$w) != {}} {wm geometry $w $cfig(geom$w)}

    frame $w.b; pack $w.b -side bottom -fill x
    tsearch::tsearch $w.b.srch $w.t.text; pack $w.b.srch -side right
    
    if {$cfig(save$w) != {}} {
        button $w.b.save -text $cfig(save$w) -command "edwin::save $w" -help "Apply the contents of this window (and any changes) to its intended destination\n(Shortcut: Alt-s)"
        if {$cfig(rdonly$w)} {$w.b.save configure -state disabled} else {
            bind $w <Alt-s> "$w.b.save invoke"
        }
        pack $w.b.save -side right -expand y -fill x
    }
    if {$cfig(quit$w)} {
        button $w.b.quit -text $cfig(abort$w) -command "set edwin::status($w) {ABORT}; destroy $w" -help "Close this editing box without applying any changes\n(Shortcut: Alt-w)"
        bind $w <Alt-w> "$w.b.quit invoke"
        pack $w.b.quit -side left
    }
    if {$cfig(print$w)} {
        button $w.b.print -text Print -command "print::print .print \{$w.t.text get 0.0 {end - 1 chars}\} -cmd 1 -wrap 80 -printer $cfig(printer$w)" -help "Print the contents of this text box"
        pack $w.b.print -side left
    }
    if {$cfig(spell$w)} {
        button $w.b.spell -text Spell -command "spell::spell $w.t.text" -help "Run a spell check on the contents of this text box"
        pack $w.b.spell -side left
    }

    frame $w.t; pack $w.t -side top -fill x
    eval text $w.t.text -xs \{$w.t.xs set\} -ys \{$w.t.ys set\} $cfig(other$w)
    scrollbar $w.t.xs -relief sunken -orient horizontal -command "$w.t.text xview"
    scrollbar $w.t.ys -relief sunken -orient vertical -command "$w.t.text yview"
    focus $w.t.text
    if {[$w.t.text cget -wrap] == {none}} {pack $w.t.xs -side bottom -fill x}
    pack $w.t.ys $w.t.text -side right -fill y -expand yes
#puts "bindtags:[bindtags $w.t.text]"
    bindtags $w.t.text "$w.t.text Text $w"	;#hack to overcome tkTraverseInMenu bug
    if {$cfig(launchcmd$w) != {}} {
        if {$cfig(launchlab$w) != {}} {
            button $w.b.launch -text $cfig(launchlab$w) -command "edwin::launch $w"
            pack $w.b.launch -side left
        }
        bind $w.t.text <Double-1> "edwin::launch $w"
        bind $w.t.text <Button-3> "edwin::launch $w"
        $w.t.text configure -cursor top_left_arrow
    }
    if {$cfig(init$w)} {
        if {$cfig(varname$w) != {}} {
            upvar $cfig(varname$w) var
            if {![info exists var]} {set var {}}
#puts "varname:$cfig(varname$w) :[uplevel set _dummy_ \$$cfig(varname$w)] : [uplevel subst \$$cfig(varname$w)]"
#            set result($w) [uplevel "subst \$$cfig(varname$w)"]  why doesn't this work?
            set result($w) [uplevel set _dummy_ \$$cfig(varname$w)]
#puts "result:$result($w)"
        } elseif {$cfig(entry$w) != {}} {
            set result($w) [$cfig(entry$w) get]
        } else {
            set result($w) {}
        }
        $w.t.text delete 0.0 end
        $w.t.text insert 0.0 $result($w)	;#result holds original value
        if {$cfig(see$w) != {}} {$w.t.text see $cfig(see$w)}
    }
    if {$cfig(insert$w) != {}} {
        $w.t.text mark set insert $cfig(insert$w)
    }
    if {$cfig(curpos$w) != {}} {
        label $w.b.cl -text $cfig(curpos$w)
        entry $w.b.cp -textvariable edwin::cfig(cpos$w) -width 8 -justify right
        pack $w.b.cp $w.b.cl -side right
        bind $w.t.text <Key> "set edwin::cfig(cpos$w) \[$w.t.text index insert\]"
        bind $w.t.text <Any-Button> "set edwin::cfig(cpos$w) \[$w.t.text index insert\]"
        bindtags $w.t.text ". Text $w.t.text"
        set edwin::cfig(cpos$w) [$w.t.text index insert]
    }
    if {$cfig(rdonly$w)} {$w.t.text configure -state disabled}

    if {$cfig(wait$w)} {
        tkwait window $w
        if {$cfig(varname$w) != {}} {		;#if writing to a local variable
            upvar $cfig(varname$w) var	;#write to a local in level above
            set var $result($w)
        }
        if {$status($w) == {OK}} {return 1} else {return 0}
    }
    rename ::$w __$w
    proc ::$w {command args} "namespace eval edwin widgcmd $w \$command \$args"	;#create widget proc
}

#The widget command for the preview box widget
#------------------------------------------
proc edwin::widgcmd {w command args} {
    switch -exact $command {
        {save}		{save $w $args}
        {launch}	{launch $args}
        {b_add}		{eval b_add $w $args}
        {default}	{eval $w.t.text $command $args}
    }
}
